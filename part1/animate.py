# -*- coding: utf-8 -*-
"""Part_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YnHzQa2unpDG8bs7F9EzctMEBRf2zN9Z
"""

import numpy as np
from math import *
import os

# The following tries to avoid a warning when run on the linux machines via ssh.
if os.environ.get('DISPLAY') is None:
     import matplotlib 
     matplotlib.use('Agg')
       
import matplotlib.pyplot as plt
import matplotlib.animation as animation

# All of the code in this file is just a starting point. Feel free
# to edit anything as you make your animation program.

# this function gets called every time a new frame should be generated.
# 
def animate_above(frame_number): 
    global tx, ty, tz, compass, tilt, twist, fl


    #going forward
    if frame_number<7.5 :
      ty+=30
    
    #taking off
    elif frame_number<25:
      ty+=30
      tz-=20

    #rotating 90 deg
    elif frame_number<40:
      compass+=pi/30
      ty+=20
    # move forward again
    elif frame_number<50:
      tx+=10
      ty+=20
   # turn right again 2nd time
    elif frame_number<65:
      compass+=pi/30
      ty+=20
   #going parallel to the airstrip
    elif frame_number<135 and frame_number<175:
      ty-=30

  #turning right 3rd time
    elif frame_number<150:

      compass+=pi/30

  #going forward again
    elif frame_number<160:
      tx-=10

  #turning right last time
    elif frame_number<175:
      compass+=pi/30

  #land the aircraft
    elif frame_number<185:
      ty+=30
    elif frame_number<225 and tz<-5: ## just keep reducing the tz till it is less than -5. 
    ## in other words, once it reaches the height 5m, stop the descent(cockpit height)
      ty+=10
      tz+=10
    elif frame_number<235:
      ty+=5

    
    fl = focal_length

    # create matrices for transformations
    ## These matrices were available on the assignment handout
    ## I have created these matrices with the help of the numpy library and creating a 2D array inside
    f_m = np.array([[fl,0,0],[0,fl,0],[0,0,1]]) ## focal matrix
    c_m = np.array([[np.cos(compass), -np.sin(compass),0], [np.sin(compass),np.cos(compass),0],[0,0,1]]) ## compass matrix
    tl_m = np.array([[1,0,0],[0, np.cos(tilt), -np.sin(tilt)],[0, np.sin(tilt),np.cos(tilt)]]) ## tilt matrix
    tw_m = np.array([[np.cos(twist),0, -np.sin(twist)],[0,1,0],[np.sin(twist),0,np.cos(twist)]]) ## twist matrix
    T_M = np.array([[1,0,0,tx],[0,1,0,ty],[0,0,1,tz]]) ## T(x,y,z) matrix

    # apply transformations to points
    ## for the projection matrix, we start with the matrix multiplication of two matrices at a time, and go on taking the 
    ## matrix multiplication with another matrix with the result of the first multiplication and so on.

    projection = np.matmul(f_m, np.matmul(tl_m,np.matmul(tw_m,np.matmul(c_m,T_M))))
    pr=[]
    pc=[]
    for p in pts3:
        p = np.append(p, 1)
        ## pts3 includes the x,y and z columns in the airports.pts  and having it's matrix multiplication with the projection matrix created above.
        ## Appended 1 with the p(pts coordinates) to match its dimension with the projection matrix.
        projection_m = np.matmul(projection, p)
        if projection_m[2] > 0:
            p1 = projection_m/projection_m[2]
            pr += [p1[0]]
            pc += [p1[1]]

    # plot points
    plt.cla()
    plt.gca().set_xlim([-fl,fl])
    plt.gca().set_ylim([fl,-fl])
    line, = plt.plot(pr, pc, 'k',  linestyle="", marker=".", markersize=2)
    return line,


# load in 3d point cloud
with open("airport.pts", "r") as f:
    pts3 = [ [ float(x) for x in l.split(" ") ] for l in f.readlines() ]

# initialize plane pose (translation and rotation)
(tx, ty, tz) = (0, 0, -5)
(compass, tilt, twist) = (pi, pi/2, 0)
focal_length=0.002 ## initializing the focal length to create the focal matrix and for setting the X and Y axis of the output
# create animation!
fig, ax  = plt.subplots()
frame_count = 225
ani = animation.FuncAnimation(fig, animate_above, frames=range(0,frame_count))

ani.save("movie.mp4")

# uncomment if you want to display the movie on the screen (won't work on the
# remote linux servers if you are connecting via ssh)
#plt.show()

